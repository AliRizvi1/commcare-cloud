{% for queue_names, celery_params in app_processes_config.celery_processes.get(inventory_hostname).items() %}
{% for worker_num in range(celery_params.num_workers) %}

[program:{{ project }}-{{ deploy_env }}-celery_{{ queue_names }}_{{worker_num}}]
environment={% for name, value in supervisor_env_vars.items %}{{ name }}="{{ value }}",{% endfor %}

command=/bin/bash {{ code_home }}/services/supervisor/{{ deploy_env }}_celery_bash_runner{% if celery_params.optimize %}_optimized{% endif %}.sh --queues={{ queue_names }} --events --loglevel=INFO --hostname={{ host_string }}_{{ queue_names }}_{{ worker_num }} {% if celery_params.pooling == 'prefork' %} --autoscale={{ celery_params.concurrency }},0 -Ofair --maxtasksperchild={{ celery_params.max_tasks_per_child }}{% endif %}{% if celery_params.pooling == 'gevent' %} -P gevent --concurrency={{ celery_params.concurrency }}{% endif %} --without-gossip
directory={{ code_home }}
user={{ cchq_user }}
numprocs=1
autostart=true
autorestart=true
stopasgroup=false
killasgroup=false
stdout_logfile={{ log_home }}/celery_{{ queue_names }}_{{ worker_num }}.log
redirect_stderr=true
stderr_logfile={{ log_home }}/celery_{{ queue_names }}_{{ worker_num }}.error.log
startsecs=10
; shutdown only waits for the bash runner to exit
stopwaitsecs = 30

{% endfor %}
{% endfor %}
